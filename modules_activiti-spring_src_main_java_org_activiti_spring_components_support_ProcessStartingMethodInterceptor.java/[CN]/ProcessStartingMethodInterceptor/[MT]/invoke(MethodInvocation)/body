{
  Method method=invocation.getMethod();
  StartProcess startProcess=AnnotationUtils.getAnnotation(method,StartProcess.class);
  final String processKey=startProcess.processKey();
  Assert.hasText(processKey,"you must provide the name of process to start");
  Object result;
  try {
    sharedProcessInstanceHolder.registerProcessInstanceCallable(new Callable<ProcessInstance>(){
      @Override public ProcessInstance call() throws Exception {
        ProcessStartingMethodInterceptor that=ProcessStartingMethodInterceptor.this;
        Map<String,Object> vars=that.processVariablesFromAnnotations(invocation);
        String businessKey=that.processBusinessKey(invocation);
        log.info("variables for the started process: {}",vars.toString());
        RuntimeService runtimeService=ProcessStartingMethodInterceptor.this.processEngine.getRuntimeService();
        ProcessInstance pi;
        if (null != businessKey && StringUtils.hasText(businessKey)) {
          pi=runtimeService.startProcessInstanceByKey(processKey,businessKey,vars);
          log.info("the business key for the started process is '{}'",businessKey);
        }
 else {
          pi=runtimeService.startProcessInstanceByKey(processKey,vars);
        }
        return pi;
      }
    }
);
    result=invocation.proceed();
    ProcessInstance pi=sharedProcessInstanceHolder.sharedProcessInstance();
    String pId=pi.getId();
    if (invocation.getMethod().getReturnType().equals(void.class))     return null;
    if (shouldReturnProcessInstance(startProcess,invocation,result))     return pi;
    if (shouldReturnProcessInstanceId(startProcess,invocation,result))     return pId;
    if (shouldReturnAsyncResultWithProcessInstance(startProcess,invocation,result)) {
      return new AsyncResult<ProcessInstance>(pi);
    }
  }
 catch (  Throwable th) {
    throw new RuntimeException(th);
  }
  return result;
}
