{
  BpmnModel bpmnModel=new BpmnModel();
  Map<String,JsonNode> shapeMap=new HashMap<String,JsonNode>();
  Map<String,JsonNode> sourceRefMap=new HashMap<String,JsonNode>();
  Map<String,JsonNode> edgeMap=new HashMap<String,JsonNode>();
  Map<String,List<JsonNode>> sourceAndTargetMap=new HashMap<String,List<JsonNode>>();
  readShapeDI(modelNode,0,0,shapeMap,sourceRefMap,bpmnModel);
  filterAllEdges(modelNode,edgeMap,sourceAndTargetMap,shapeMap,sourceRefMap);
  readEdgeDI(edgeMap,sourceAndTargetMap,bpmnModel);
  ArrayNode shapesArrayNode=(ArrayNode)modelNode.get(EDITOR_CHILD_SHAPES);
  boolean emptyPoolFound=true;
  for (  JsonNode shapeNode : shapesArrayNode) {
    String stencilId=BpmnJsonConverterUtil.getStencilId(shapeNode);
    if (STENCIL_POOL.equals(stencilId)) {
      Pool pool=new Pool();
      pool.setId(BpmnJsonConverterUtil.getElementId(shapeNode));
      pool.setName(JsonConverterUtil.getPropertyValueAsString(PROPERTY_NAME,shapeNode));
      pool.setProcessRef(JsonConverterUtil.getPropertyValueAsString(PROPERTY_PROCESS_ID,shapeNode));
      pool.setExecutable(JsonConverterUtil.getPropertyValueAsBoolean(PROPERTY_PROCESS_EXECUTABLE,shapeNode,true));
      bpmnModel.getPools().add(pool);
      Process process=new Process();
      process.setId(pool.getProcessRef());
      process.setName(pool.getName());
      process.setExecutable(pool.isExecutable());
      bpmnModel.addProcess(process);
      processJsonElements(shapesArrayNode,modelNode,process,shapeMap);
      ArrayNode laneArrayNode=(ArrayNode)shapeNode.get(EDITOR_CHILD_SHAPES);
      for (      JsonNode laneNode : laneArrayNode) {
        String laneStencilId=BpmnJsonConverterUtil.getStencilId(laneNode);
        if (STENCIL_LANE.equals(laneStencilId)) {
          emptyPoolFound=false;
          Lane lane=new Lane();
          lane.setId(BpmnJsonConverterUtil.getElementId(laneNode));
          lane.setName(JsonConverterUtil.getPropertyValueAsString(PROPERTY_NAME,laneNode));
          lane.setParentProcess(process);
          process.getLanes().add(lane);
          processJsonElements(laneNode.get(EDITOR_CHILD_SHAPES),modelNode,lane,shapeMap);
        }
      }
    }
  }
  if (emptyPoolFound) {
    JsonNode processIdNode=JsonConverterUtil.getProperty(PROPERTY_PROCESS_ID,modelNode);
    Process process=new Process();
    bpmnModel.getProcesses().add(process);
    if (processIdNode != null && StringUtils.isNotEmpty(processIdNode.asText())) {
      process.setId(processIdNode.asText());
    }
    JsonNode processNameNode=JsonConverterUtil.getProperty(PROPERTY_NAME,modelNode);
    if (processNameNode != null && StringUtils.isNotEmpty(processNameNode.asText())) {
      process.setName(processNameNode.asText());
    }
    JsonNode processExecutableNode=JsonConverterUtil.getProperty(PROPERTY_PROCESS_EXECUTABLE,modelNode);
    if (processExecutableNode != null && StringUtils.isNotEmpty(processExecutableNode.asText())) {
      process.setExecutable(JsonConverterUtil.getPropertyValueAsBoolean(PROPERTY_PROCESS_EXECUTABLE,modelNode));
    }
    JsonNode processTargetNamespace=JsonConverterUtil.getProperty(PROPERTY_PROCESS_NAMESPACE,modelNode);
    if (processTargetNamespace != null && StringUtils.isNotEmpty(processTargetNamespace.asText())) {
      bpmnModel.setTargetNamespace(processTargetNamespace.asText());
    }
    JsonNode processExecutionListenerNode=modelNode.get(EDITOR_SHAPE_PROPERTIES).get(PROPERTY_EXECUTION_LISTENERS);
    if (processExecutionListenerNode != null && StringUtils.isNotEmpty(processExecutionListenerNode.asText())) {
      process.setExecutionListeners(convertJsonToListeners(processExecutionListenerNode));
    }
    JsonNode processEventListenerNode=modelNode.get(EDITOR_SHAPE_PROPERTIES).get(PROPERTY_EVENT_LISTENERS);
    if (processEventListenerNode != null) {
      process.setEventListeners(convertJsonToEventListeners(processEventListenerNode));
    }
    processJsonElements(shapesArrayNode,modelNode,process,shapeMap);
  }
  Map<String,SubProcess> subShapesMap=new HashMap<String,SubProcess>();
  for (  Process process : bpmnModel.getProcesses()) {
    for (    FlowElement flowElement : process.findFlowElementsOfType(SubProcess.class)) {
      SubProcess subProcess=(SubProcess)flowElement;
      fillSubShapes(subShapesMap,subProcess);
    }
    if (subShapesMap.size() > 0) {
      List<String> removeSubFlowsList=new ArrayList<String>();
      List<SequenceFlow> sequenceFlowList=process.findFlowElementsOfType(SequenceFlow.class);
      for (      FlowElement flowElement : sequenceFlowList) {
        SequenceFlow sequenceFlow=(SequenceFlow)flowElement;
        if (process.getFlowElement(flowElement.getId()) != null && subShapesMap.containsKey(sequenceFlow.getSourceRef())) {
          SubProcess subProcess=subShapesMap.get(sequenceFlow.getSourceRef());
          subProcess.addFlowElement(sequenceFlow);
          removeSubFlowsList.add(sequenceFlow.getId());
        }
      }
      for (      String flowId : removeSubFlowsList) {
        process.removeFlowElement(flowId);
      }
    }
  }
  for (  Process process : bpmnModel.getProcesses()) {
    postProcessElements(process,process.getFlowElements());
  }
  return bpmnModel;
}
