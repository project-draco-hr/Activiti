{
  BpmnModel bpmnModel=new BpmnModel();
  Map<String,JsonNode> shapeMap=new HashMap<String,JsonNode>();
  Map<String,JsonNode> sourceRefMap=new HashMap<String,JsonNode>();
  Map<String,JsonNode> edgeMap=new HashMap<String,JsonNode>();
  Map<String,List<JsonNode>> sourceAndTargetMap=new HashMap<String,List<JsonNode>>();
  readShapeDI(modelNode,0,0,shapeMap,sourceRefMap,bpmnModel);
  filterAllEdges(modelNode,edgeMap,sourceAndTargetMap,shapeMap,sourceRefMap);
  readEdgeDI(edgeMap,sourceAndTargetMap,bpmnModel);
  ArrayNode shapesArrayNode=(ArrayNode)modelNode.get(EDITOR_CHILD_SHAPES);
  boolean nonEmptyPoolFound=false;
  for (  JsonNode shapeNode : shapesArrayNode) {
    String stencilId=BpmnJsonConverterUtil.getStencilId(shapeNode);
    if (STENCIL_POOL.equals(stencilId)) {
      Pool pool=new Pool();
      pool.setId(BpmnJsonConverterUtil.getElementId(shapeNode));
      pool.setName(JsonConverterUtil.getPropertyValueAsString(PROPERTY_NAME,shapeNode));
      bpmnModel.getPools().add(pool);
      Process process=new Process();
      process.setId("Process_" + pool.getId());
      bpmnModel.addProcess(process);
      pool.setProcessRef(process.getId());
      ArrayNode laneArrayNode=(ArrayNode)shapeNode.get(EDITOR_CHILD_SHAPES);
      for (      JsonNode laneNode : laneArrayNode) {
        String laneStencilId=BpmnJsonConverterUtil.getStencilId(laneNode);
        if (STENCIL_LANE.equals(laneStencilId)) {
          nonEmptyPoolFound=true;
          Lane lane=new Lane();
          lane.setId(BpmnJsonConverterUtil.getElementId(laneNode));
          lane.setName(JsonConverterUtil.getPropertyValueAsString(PROPERTY_NAME,laneNode));
          lane.setParentProcess(process);
          process.getLanes().add(lane);
          processJsonElements(laneNode.get(EDITOR_CHILD_SHAPES),modelNode,lane,shapeMap);
        }
      }
    }
  }
  if (nonEmptyPoolFound == false) {
    JsonNode processIdNode=modelNode.get(EDITOR_SHAPE_PROPERTIES).get(PROPERTY_PROCESS_ID);
    Process process=new Process();
    bpmnModel.getProcesses().add(process);
    if (processIdNode != null && StringUtils.isNotEmpty(processIdNode.asText())) {
      process.setId(processIdNode.asText());
    }
    JsonNode processNameNode=modelNode.get(EDITOR_SHAPE_PROPERTIES).get(PROPERTY_NAME);
    if (processNameNode != null && StringUtils.isNotEmpty(processNameNode.asText())) {
      process.setName(processNameNode.asText());
    }
    processJsonElements(shapesArrayNode,modelNode,process,shapeMap);
  }
  Map<String,SubProcess> subShapesMap=new HashMap<String,SubProcess>();
  for (  Process process : bpmnModel.getProcesses()) {
    for (    FlowElement flowElement : process.getFlowElements()) {
      if (flowElement instanceof SubProcess) {
        SubProcess subProcess=(SubProcess)flowElement;
        fillSubShapes(subShapesMap,subProcess);
      }
    }
    if (subShapesMap.size() > 0) {
      List<String> removeSubFlowsList=new ArrayList<String>();
      for (      FlowElement flowElement : process.getFlowElements()) {
        if (flowElement instanceof SequenceFlow) {
          SequenceFlow sequenceFlow=(SequenceFlow)flowElement;
          if (subShapesMap.containsKey(sequenceFlow.getSourceRef())) {
            SubProcess subProcess=subShapesMap.get(sequenceFlow.getSourceRef());
            subProcess.addFlowElement(sequenceFlow);
            removeSubFlowsList.add(sequenceFlow.getId());
          }
        }
      }
      for (      String flowId : removeSubFlowsList) {
        process.removeFlowElement(flowId);
      }
    }
  }
  Map<String,SequenceFlow> flowSourceMap=new HashMap<String,SequenceFlow>();
  Map<String,SequenceFlow> flowTargetMap=new HashMap<String,SequenceFlow>();
  for (  Process process : bpmnModel.getProcesses()) {
    addAllSequenceFlows(process.getFlowElements(),flowSourceMap,flowTargetMap);
  }
  for (  Process process : bpmnModel.getProcesses()) {
    postProcessElements(process,process.getFlowElements(),flowSourceMap,flowTargetMap);
  }
  return bpmnModel;
}
