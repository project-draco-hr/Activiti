{
  for (  Element endEventElement : parentElement.elements("endEvent")) {
    ActivityImpl activity=createActivityOnScope(endEventElement,scope);
    Element errorEventDefinition=endEventElement.element("errorEventDefinition");
    Element cancelEventDefinition=endEventElement.element("cancelEventDefinition");
    if (errorEventDefinition != null) {
      String errorRef=errorEventDefinition.attribute("errorRef");
      if (errorRef == null || "".equals(errorRef)) {
        addError("'errorRef' attribute is mandatory on error end event",errorEventDefinition);
      }
 else {
        Error error=errors.get(errorRef);
        if (error != null && (error.getErrorCode() == null || "".equals(error.getErrorCode()))) {
          addError("'errorCode' is mandatory on errors referenced by throwing error event definitions, but the error '" + error.getId() + "' does not define one.",errorEventDefinition);
        }
        activity.setProperty("type","errorEndEvent");
        activity.setActivityBehavior(new ErrorEndEventActivityBehavior(error != null ? error.getErrorCode() : errorRef));
      }
    }
 else     if (cancelEventDefinition != null) {
      if (scope.getProperty("type") == null || !scope.getProperty("type").equals("transaction")) {
        addError("end event with cancelEventDefinition only supported inside transaction subprocess",cancelEventDefinition);
      }
 else {
        activity.setProperty("type","cancelEndEvent");
        activity.setActivityBehavior(new CancelEndEventActivityBehavior());
      }
    }
 else {
      activity.setActivityBehavior(new NoneEndEventActivityBehavior());
    }
    for (    BpmnParseListener parseListener : parseListeners) {
      parseListener.parseEndEvent(endEventElement,scope,activity);
    }
    parseExecutionListenersOnScope(endEventElement,activity);
  }
}
