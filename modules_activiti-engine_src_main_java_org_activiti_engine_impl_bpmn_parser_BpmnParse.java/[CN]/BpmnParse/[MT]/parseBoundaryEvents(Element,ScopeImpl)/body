{
  for (  Element boundaryEventElement : parentElement.elements("boundaryEvent")) {
    String attachedToRef=boundaryEventElement.attribute("attachedToRef");
    if (attachedToRef == null || attachedToRef.equals("")) {
      addError("AttachedToRef is required when using a timerEventDefinition",boundaryEventElement);
    }
    String id=boundaryEventElement.attribute("id");
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug("Parsing boundary event {}",id);
    }
    ActivityImpl parentActivity=scopeElement.findActivity(attachedToRef);
    if (parentActivity == null) {
      addError("Invalid reference in boundary event. Make sure that the referenced activity is " + "defined in the same scope as the boundary event",boundaryEventElement);
    }
    ActivityImpl nestedActivity=createActivityOnScope(boundaryEventElement,parentActivity);
    String cancelActivity=boundaryEventElement.attribute("cancelActivity","true");
    boolean interrupting=cancelActivity.equals("true") ? true : false;
    ActivityBehavior behavior=null;
    Element timerEventDefinition=boundaryEventElement.element("timerEventDefinition");
    Element errorEventDefinition=boundaryEventElement.element("errorEventDefinition");
    Element signalEventDefinition=boundaryEventElement.element("signalEventDefinition");
    Element cancelEventDefinition=boundaryEventElement.element("cancelEventDefinition");
    Element compensateEventDefinition=boundaryEventElement.element("compensateEventDefinition");
    Element messageEventDefinition=boundaryEventElement.element("messageEventDefinition");
    if (timerEventDefinition != null) {
      behavior=new BoundaryEventActivityBehavior(interrupting,nestedActivity.getId());
      parseBoundaryTimerEventDefinition(timerEventDefinition,interrupting,nestedActivity);
    }
 else     if (errorEventDefinition != null) {
      interrupting=true;
      behavior=new BoundaryEventActivityBehavior(interrupting,nestedActivity.getId());
      parseBoundaryErrorEventDefinition(errorEventDefinition,interrupting,parentActivity,nestedActivity);
    }
 else     if (signalEventDefinition != null) {
      behavior=new BoundaryEventActivityBehavior(interrupting,nestedActivity.getId());
      parseBoundarySignalEventDefinition(signalEventDefinition,interrupting,nestedActivity);
    }
 else     if (cancelEventDefinition != null) {
      behavior=parseBoundaryCancelEventDefinition(cancelEventDefinition,nestedActivity);
    }
 else     if (compensateEventDefinition != null) {
      behavior=new BoundaryEventActivityBehavior(interrupting,nestedActivity.getId());
      parseCatchCompensateEventDefinition(compensateEventDefinition,nestedActivity);
    }
 else     if (messageEventDefinition != null) {
      behavior=new BoundaryEventActivityBehavior(interrupting,nestedActivity.getId());
      parseBoundaryMessageEventDefinition(messageEventDefinition,interrupting,nestedActivity);
    }
 else {
      addError("Unsupported boundary event type",boundaryEventElement);
    }
    for (    BpmnParseListener parseListener : parseListeners) {
      parseListener.parseBoundaryEvent(boundaryEventElement,scopeElement,nestedActivity);
    }
    nestedActivity.setActivityBehavior(behavior);
  }
}
