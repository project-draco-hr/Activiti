{
  transitions=new ArrayList<PvmTransition>(transitions);
  recyclableExecutions=new ArrayList<ActivityExecution>(recyclableExecutions);
  ExecutionImpl concurrentRoot=(isConcurrent() ? getParent() : this);
  List<ExecutionImpl> concurrentActiveExecutions=new ArrayList<ExecutionImpl>();
  for (  ExecutionImpl execution : concurrentRoot.getExecutions()) {
    if (execution.isActive()) {
      concurrentActiveExecutions.add(execution);
    }
  }
  if (log.isLoggable(Level.FINE)) {
    log.fine("transitions to take concurrent: " + transitions);
    log.fine("active concurrent executions: " + concurrentActiveExecutions);
  }
  if ((transitions.size() == 1) && (concurrentActiveExecutions.isEmpty())) {
    List<ExecutionImpl> recyclableExecutionImpls=(List)recyclableExecutions;
    for (    ExecutionImpl prunedExecution : recyclableExecutionImpls) {
      if (!prunedExecution.isEnded()) {
        log.info("pruning execution " + prunedExecution);
        prunedExecution.getParent().removeExecution(prunedExecution);
      }
    }
    log.info("activating the concurrent root execution as the single path of execution going forward");
    concurrentRoot.setActive(true);
    concurrentRoot.setActivity(activity);
    concurrentRoot.setConcurrent(false);
    concurrentRoot.take(transitions.get(0));
  }
 else {
    List<OutgoingExecution> outgoingExecutions=new ArrayList<OutgoingExecution>();
    recyclableExecutions.remove(concurrentRoot);
    log.fine("recyclable executions for reused: " + recyclableExecutions);
    while (!transitions.isEmpty()) {
      PvmTransition outgoingTransition=transitions.remove(0);
      if (recyclableExecutions.isEmpty()) {
        ActivityExecution outgoingExecution=concurrentRoot.createExecution();
        outgoingExecutions.add(new OutgoingExecution(outgoingExecution,outgoingTransition,true));
        log.fine("new " + outgoingExecution + " created to take transition "+ outgoingTransition);
      }
 else {
        ActivityExecution outgoingExecution=recyclableExecutions.remove(0);
        outgoingExecutions.add(new OutgoingExecution(outgoingExecution,outgoingTransition,true));
        log.fine("recycled " + outgoingExecution + " to take transition "+ outgoingTransition);
      }
    }
    for (    ActivityExecution prunedExecution : recyclableExecutions) {
      log.info("pruning execution " + prunedExecution);
      prunedExecution.end();
    }
    for (    OutgoingExecution outgoingExecution : outgoingExecutions) {
      outgoingExecution.take();
    }
  }
}
