{
  if (recyclableExecutions.size() > 1) {
    for (    ActivityExecution recyclableExecution : recyclableExecutions) {
      if (((ExecutionImpl)recyclableExecution).isScope()) {
        throw new PvmException("joining scope executions is not allowed");
      }
    }
  }
  transitions=new ArrayList<PvmTransition>(transitions);
  recyclableExecutions=(recyclableExecutions != null ? new ArrayList<ActivityExecution>(recyclableExecutions) : new ArrayList<ActivityExecution>());
  ExecutionImpl concurrentRoot=(isConcurrent() ? getParent() : this);
  List<ExecutionImpl> concurrentActiveExecutions=new ArrayList<ExecutionImpl>();
  for (  ExecutionImpl execution : concurrentRoot.getExecutions()) {
    if (execution.isActive()) {
      concurrentActiveExecutions.add(execution);
    }
  }
  if (log.isLoggable(Level.FINE)) {
    log.fine("transitions to take concurrent: " + transitions);
    log.fine("active concurrent executions: " + concurrentActiveExecutions);
  }
  if ((transitions.size() == 1) && (concurrentActiveExecutions.isEmpty())) {
    List<ExecutionImpl> recyclableExecutionImpls=(List)recyclableExecutions;
    for (    ExecutionImpl prunedExecution : recyclableExecutionImpls) {
      if (!prunedExecution.isEnded()) {
        log.fine("pruning execution " + prunedExecution);
        prunedExecution.remove();
      }
    }
    log.fine("activating the concurrent root " + concurrentRoot + " as the single path of execution going forward");
    concurrentRoot.setActive(true);
    concurrentRoot.setActivity(activity);
    concurrentRoot.setConcurrent(false);
    concurrentRoot.take(transitions.get(0));
  }
 else {
    List<OutgoingExecution> outgoingExecutions=new ArrayList<OutgoingExecution>();
    recyclableExecutions.remove(concurrentRoot);
    log.fine("recyclable executions for reused: " + recyclableExecutions);
    while (!transitions.isEmpty()) {
      PvmTransition outgoingTransition=transitions.remove(0);
      if (recyclableExecutions.isEmpty()) {
        ActivityExecution outgoingExecution=concurrentRoot.createExecution();
        outgoingExecution.setActive(true);
        outgoingExecution.setConcurrent(true);
        outgoingExecutions.add(new OutgoingExecution(outgoingExecution,outgoingTransition,true));
        log.fine("new " + outgoingExecution + " created to take transition "+ outgoingTransition);
      }
 else {
        ActivityExecution outgoingExecution=recyclableExecutions.remove(0);
        outgoingExecution.setActive(true);
        outgoingExecution.setConcurrent(true);
        outgoingExecutions.add(new OutgoingExecution(outgoingExecution,outgoingTransition,true));
        log.fine("recycled " + outgoingExecution + " to take transition "+ outgoingTransition);
      }
    }
    for (    ActivityExecution prunedExecution : recyclableExecutions) {
      log.info("pruning execution " + prunedExecution);
      prunedExecution.end();
    }
    for (    OutgoingExecution outgoingExecution : outgoingExecutions) {
      outgoingExecution.take();
    }
  }
}
