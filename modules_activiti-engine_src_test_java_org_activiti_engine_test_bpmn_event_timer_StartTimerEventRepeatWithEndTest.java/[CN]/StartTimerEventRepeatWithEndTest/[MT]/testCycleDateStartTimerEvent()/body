{
  Clock previousClock=processEngineConfiguration.getClock();
  Clock testClock=new DefaultClockImpl();
  processEngineConfiguration.setClock(testClock);
  Calendar calendar=Calendar.getInstance();
  calendar.set(2025,Calendar.DECEMBER,10,0,0,0);
  testClock.setCurrentTime(calendar.getTime());
  repositoryService.createDeployment().addClasspathResource("org/activiti/engine/test/bpmn/event/timer/StartTimerEventRepeatWithEndTest.testCycleDateStartTimerEvent.bpmn20.xml").deploy();
  assertEquals(1,repositoryService.createProcessDefinitionQuery().count());
  listener.clearEventsReceived();
  try {
    waitForJobExecutorToProcessAllJobs(2000,500);
    fail("there must be a pending job because the endDate is not reached yet");
  }
 catch (  Exception e) {
  }
  moveByMinutes(60 * 24);
  try {
    waitForJobExecutorToProcessAllJobs(2000,500);
    fail("there must be a pending job because the endDate is not reached yet");
  }
 catch (  Exception e) {
  }
  moveByMinutes(60 * 24);
  try {
    waitForJobExecutorToProcessAllJobs(2000,500);
  }
 catch (  Exception e) {
    fail("Because the endDate is reached it will not be executed other jobs");
  }
  moveByMinutes(60 * 24);
  try {
    waitForJobExecutorToProcessAllJobs(2000,500);
  }
 catch (  Exception e) {
    fail("Because the endDate is reached it will not be executed other jobs");
  }
  int timerFiredCount=0;
  List<ActivitiEvent> eventsReceived=listener.getEventsReceived();
  for (  ActivitiEvent eventReceived : eventsReceived) {
    if (ActivitiEventType.TIMER_FIRED.equals(eventReceived.getType())) {
      timerFiredCount++;
    }
  }
  listener.clearEventsReceived();
  processEngineConfiguration.setClock(previousClock);
  assertEquals(2,timerFiredCount);
  repositoryService.deleteDeployment(repositoryService.createDeploymentQuery().singleResult().getId(),true);
}
